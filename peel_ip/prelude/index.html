<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `prelude` mod in crate `peel_ip`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, prelude">

    <title>peel_ip::prelude - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>peel_ip</a></p><script>window.sidebarCurrent = {name: 'prelude', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>peel_ip</a>::<wbr><a class='mod' href=''>prelude</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../src/peel_ip/lib.rs.html#30-70' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Provides sensible imports for packet parsers</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use nom::*;</code></td></tr><tr><td><code>pub use peel::prelude::*;</code></td></tr><tr><td><code>pub use super::<a class='trait' href='../../peel_ip/trait.NewPeelIp.html' title='peel_ip::NewPeelIp'>NewPeelIp</a>;</code></td></tr><tr><td><code>pub use <a class='mod' href='../../peel_ip/layer1/index.html' title='peel_ip::layer1'>layer1</a>::*;</code></td></tr><tr><td><code>pub use layer1::<a class='mod' href='../../peel_ip/layer1/ethernet/index.html' title='peel_ip::layer1::ethernet'>ethernet</a>::*;</code></td></tr><tr><td><code>pub use layer1::<a class='mod' href='../../peel_ip/layer1/arp/index.html' title='peel_ip::layer1::arp'>arp</a>::*;</code></td></tr><tr><td><code>pub use <a class='mod' href='../../peel_ip/layer2/index.html' title='peel_ip::layer2'>layer2</a>::*;</code></td></tr><tr><td><code>pub use layer2::<a class='mod' href='../../peel_ip/layer2/ipv4/index.html' title='peel_ip::layer2::ipv4'>ipv4</a>::*;</code></td></tr><tr><td><code>pub use layer2::<a class='mod' href='../../peel_ip/layer2/ipv6/index.html' title='peel_ip::layer2::ipv6'>ipv6</a>::*;</code></td></tr><tr><td><code>pub use layer2::<a class='mod' href='../../peel_ip/layer2/icmp/index.html' title='peel_ip::layer2::icmp'>icmp</a>::*;</code></td></tr><tr><td><code>pub use layer2::<a class='mod' href='../../peel_ip/layer2/icmpv6/index.html' title='peel_ip::layer2::icmpv6'>icmpv6</a>::*;</code></td></tr><tr><td><code>pub use <a class='mod' href='../../peel_ip/layer3/index.html' title='peel_ip::layer3'>layer3</a>::*;</code></td></tr><tr><td><code>pub use layer3::<a class='mod' href='../../peel_ip/layer3/tcp/index.html' title='peel_ip::layer3::tcp'>tcp</a>::*;</code></td></tr><tr><td><code>pub use layer3::<a class='mod' href='../../peel_ip/layer3/tls/index.html' title='peel_ip::layer3::tls'>tls</a>::*;</code></td></tr><tr><td><code>pub use layer3::<a class='mod' href='../../peel_ip/layer3/udp/index.html' title='peel_ip::layer3::udp'>udp</a>::*;</code></td></tr><tr><td><code>pub use layer4::<a class='mod' href='../../peel_ip/layer4/http/index.html' title='peel_ip::layer4::http'>http</a>::*;</code></td></tr><tr><td><code>pub use layer4::<a class='mod' href='../../peel_ip/layer4/ntp/index.html' title='peel_ip::layer4::ntp'>ntp</a>::*;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='mod' href='fmt/index.html'
                                  title='peel_ip::prelude::fmt'>fmt</a></td>
                           <td class='docblock-short'>
                                <p>Utilities for formatting and printing <code>String</code>s</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='str/index.html'
                                  title='peel_ip::prelude::str'>str</a></td>
                           <td class='docblock-short'>
                                <p>Unicode string slices.</p>
                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.add_return_error.html'
                                  title='peel_ip::prelude::add_return_error'>add_return_error</a></td>
                           <td class='docblock-short'>
                                <p>Add an error if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.alt.html'
                                  title='peel_ip::prelude::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p><code>alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
try a list of parsers, return the result of the first successful one</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.alt_complete.html'
                                  title='peel_ip::prelude::alt_complete'>alt_complete</a></td>
                           <td class='docblock-short'>
                                <p>This is a combination of the <code>alt!</code> and <code>complete!</code> combinators. Rather
than returning <code>Incomplete</code> on partial input, <code>alt_complete!</code> will try the
next alternative in the chain. You should use this only if you know you
will not receive partial input for the rules you&#39;re trying to match (this
is almost always the case for parsing programming languages).</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.apply.html'
                                  title='peel_ip::prelude::apply'>apply</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.apply_m.html'
                                  title='peel_ip::prelude::apply_m'>apply_m</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.bits.html'
                                  title='peel_ip::prelude::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p><code>bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;</code>
transforms its byte slice input into a bit stream for the underlying parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.call.html'
                                  title='peel_ip::prelude::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Used to wrap common expressions and function as macros</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.call_m.html'
                                  title='peel_ip::prelude::call_m'>call_m</a></td>
                           <td class='docblock-short'>
                                <p>Used to called methods then move self back into self</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.chain.html'
                                  title='peel_ip::prelude::chain'>chain</a></td>
                           <td class='docblock-short'>
                                <p>[DEPRECATED] <code>chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
chains parsers and assemble the results through a closure</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.char.html'
                                  title='peel_ip::prelude::char'>char</a></td>
                           <td class='docblock-short'>
                                <p>matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.closure.html'
                                  title='peel_ip::prelude::closure'>closure</a></td>
                           <td class='docblock-short'>
                                <p>Wraps a parser in a closure</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.complete.html'
                                  title='peel_ip::prelude::complete'>complete</a></td>
                           <td class='docblock-short'>
                                <p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.cond.html'
                                  title='peel_ip::prelude::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.cond_reduce.html'
                                  title='peel_ip::prelude::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.cond_with_error.html'
                                  title='peel_ip::prelude::cond_with_error'>cond_with_error</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.consumer_from_parser.html'
                                  title='peel_ip::prelude::consumer_from_parser'>consumer_from_parser</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.count.html'
                                  title='peel_ip::prelude::count'>count</a></td>
                           <td class='docblock-short'>
                                <p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.count_fixed.html'
                                  title='peel_ip::prelude::count_fixed'>count_fixed</a></td>
                           <td class='docblock-short'>
                                <p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.dbg.html'
                                  title='peel_ip::prelude::dbg'>dbg</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.dbg_dmp.html'
                                  title='peel_ip::prelude::dbg_dmp'>dbg_dmp</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message and the input if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.delimited.html'
                                  title='peel_ip::prelude::delimited'>delimited</a></td>
                           <td class='docblock-short'>
                                <p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.do_parse.html'
                                  title='peel_ip::prelude::do_parse'>do_parse</a></td>
                           <td class='docblock-short'>
                                <p><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.eat_separator.html'
                                  title='peel_ip::prelude::eat_separator'>eat_separator</a></td>
                           <td class='docblock-short'>
                                <p>helper macros to build a separator parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.eof.html'
                                  title='peel_ip::prelude::eof'>eof</a></td>
                           <td class='docblock-short'>
                                <p><code>eof!(i)</code> returns <code>i</code> if it is at the end of input data</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.error_code.html'
                                  title='peel_ip::prelude::error_code'>error_code</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.error_node.html'
                                  title='peel_ip::prelude::error_node'>error_node</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the next error in the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.error_node_position.html'
                                  title='peel_ip::prelude::error_node_position'>error_node_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.error_position.html'
                                  title='peel_ip::prelude::error_position'>error_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.escaped.html'
                                  title='peel_ip::prelude::escaped'>escaped</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.escaped_transform.html'
                                  title='peel_ip::prelude::escaped_transform'>escaped_transform</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.expr_opt.html'
                                  title='peel_ip::prelude::expr_opt'>expr_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.expr_res.html'
                                  title='peel_ip::prelude::expr_res'>expr_res</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.fix_error.html'
                                  title='peel_ip::prelude::fix_error'>fix_error</a></td>
                           <td class='docblock-short'>
                                <p>translate parser result from IResult<I,O,u32> to IResult<I,O,E> with a custom type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.flat_map.html'
                                  title='peel_ip::prelude::flat_map'>flat_map</a></td>
                           <td class='docblock-short'>
                                <p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.fold_many0.html'
                                  title='peel_ip::prelude::fold_many0'>fold_many0</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.fold_many1.html'
                                  title='peel_ip::prelude::fold_many1'>fold_many1</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.fold_many_m_n.html'
                                  title='peel_ip::prelude::fold_many_m_n'>fold_many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.i16.html'
                                  title='peel_ip::prelude::i16'>i16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.i32.html'
                                  title='peel_ip::prelude::i32'>i32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.i64.html'
                                  title='peel_ip::prelude::i64'>i64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.is_a.html'
                                  title='peel_ip::prelude::is_a'>is_a</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.is_a_s.html'
                                  title='peel_ip::prelude::is_a_s'>is_a_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.is_not.html'
                                  title='peel_ip::prelude::is_not'>is_not</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.is_not_s.html'
                                  title='peel_ip::prelude::is_not_s'>is_not_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.length_bytes.html'
                                  title='peel_ip::prelude::length_bytes'>length_bytes</a></td>
                           <td class='docblock-short'>
                                <p><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.length_count.html'
                                  title='peel_ip::prelude::length_count'>length_count</a></td>
                           <td class='docblock-short'>
                                <p><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.length_data.html'
                                  title='peel_ip::prelude::length_data'>length_data</a></td>
                           <td class='docblock-short'>
                                <p><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.length_value.html'
                                  title='peel_ip::prelude::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                <p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, takes a subslice of the input of that size,
then applies the second parser on that subslice. If the second parser returns
<code>Incomplete</code>, <code>length_value</code> will return an error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.many0.html'
                                  title='peel_ip::prelude::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.many1.html'
                                  title='peel_ip::prelude::many1'>many1</a></td>
                           <td class='docblock-short'>
                                <p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.many_m_n.html'
                                  title='peel_ip::prelude::many_m_n'>many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.many_till.html'
                                  title='peel_ip::prelude::many_till'>many_till</a></td>
                           <td class='docblock-short'>
                                <p><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.map.html'
                                  title='peel_ip::prelude::map'>map</a></td>
                           <td class='docblock-short'>
                                <p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.map_opt.html'
                                  title='peel_ip::prelude::map_opt'>map_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.map_res.html'
                                  title='peel_ip::prelude::map_res'>map_res</a></td>
                           <td class='docblock-short'>
                                <p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.method.html'
                                  title='peel_ip::prelude::method'>method</a></td>
                           <td class='docblock-short'>
                                <p>Makes a method from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.named.html'
                                  title='peel_ip::prelude::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.named_args.html'
                                  title='peel_ip::prelude::named_args'>named_args</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination with arguments.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.named_attr.html'
                                  title='peel_ip::prelude::named_attr'>named_attr</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination, with attributes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.none_of.html'
                                  title='peel_ip::prelude::none_of'>none_of</a></td>
                           <td class='docblock-short'>
                                <p>matches anything but the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.not.html'
                                  title='peel_ip::prelude::not'>not</a></td>
                           <td class='docblock-short'>
                                <p><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Incomplete
does not consume the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.one_of.html'
                                  title='peel_ip::prelude::one_of'>one_of</a></td>
                           <td class='docblock-short'>
                                <p>matches one of the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.opt.html'
                                  title='peel_ip::prelude::opt'>opt</a></td>
                           <td class='docblock-short'>
                                <p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.opt_res.html'
                                  title='peel_ip::prelude::opt_res'>opt_res</a></td>
                           <td class='docblock-short'>
                                <p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.pair.html'
                                  title='peel_ip::prelude::pair'>pair</a></td>
                           <td class='docblock-short'>
                                <p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.parse_to.html'
                                  title='peel_ip::prelude::parse_to'>parse_to</a></td>
                           <td class='docblock-short'>
                                <p><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.peek.html'
                                  title='peel_ip::prelude::peek'>peek</a></td>
                           <td class='docblock-short'>
                                <p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.permutation.html'
                                  title='peel_ip::prelude::permutation'>permutation</a></td>
                           <td class='docblock-short'>
                                <p><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.preceded.html'
                                  title='peel_ip::prelude::preceded'>preceded</a></td>
                           <td class='docblock-short'>
                                <p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.recognize.html'
                                  title='peel_ip::prelude::recognize'>recognize</a></td>
                           <td class='docblock-short'>
                                <p><code>recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.return_error.html'
                                  title='peel_ip::prelude::return_error'>return_error</a></td>
                           <td class='docblock-short'>
                                <p>Prevents backtracking if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.sep.html'
                                  title='peel_ip::prelude::sep'>sep</a></td>
                           <td class='docblock-short'>
                                <p>sep is the parser rewriting macro for whitespace separated formats</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.separated_list.html'
                                  title='peel_ip::prelude::separated_list'>separated_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.separated_nonempty_list.html'
                                  title='peel_ip::prelude::separated_nonempty_list'>separated_nonempty_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.separated_pair.html'
                                  title='peel_ip::prelude::separated_pair'>separated_pair</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.switch.html'
                                  title='peel_ip::prelude::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tag.html'
                                  title='peel_ip::prelude::tag'>tag</a></td>
                           <td class='docblock-short'>
                                <p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tag_bits.html'
                                  title='peel_ip::prelude::tag_bits'>tag_bits</a></td>
                           <td class='docblock-short'>
                                <p>matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tag_no_case.html'
                                  title='peel_ip::prelude::tag_no_case'>tag_no_case</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tag_no_case_s.html'
                                  title='peel_ip::prelude::tag_no_case_s'>tag_no_case_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tag_s.html'
                                  title='peel_ip::prelude::tag_s'>tag_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take.html'
                                  title='peel_ip::prelude::take'>take</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_bits.html'
                                  title='peel_ip::prelude::take_bits'>take_bits</a></td>
                           <td class='docblock-short'>
                                <p><code>take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;</code>
generates a parser consuming the specified number of bits.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_s.html'
                                  title='peel_ip::prelude::take_s'>take_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_str.html'
                                  title='peel_ip::prelude::take_str'>take_str</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_till.html'
                                  title='peel_ip::prelude::take_till'>take_till</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_till_s.html'
                                  title='peel_ip::prelude::take_till_s'>take_till_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until.html'
                                  title='peel_ip::prelude::take_until'>take_until</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until_and_consume.html'
                                  title='peel_ip::prelude::take_until_and_consume'>take_until_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until_and_consume_s.html'
                                  title='peel_ip::prelude::take_until_and_consume_s'>take_until_and_consume_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until_either.html'
                                  title='peel_ip::prelude::take_until_either'>take_until_either</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until_either_and_consume.html'
                                  title='peel_ip::prelude::take_until_either_and_consume'>take_until_either_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_until_s.html'
                                  title='peel_ip::prelude::take_until_s'>take_until_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_while.html'
                                  title='peel_ip::prelude::take_while'>take_while</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_while1.html'
                                  title='peel_ip::prelude::take_while1'>take_while1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_while1_s.html'
                                  title='peel_ip::prelude::take_while1_s'>take_while1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.take_while_s.html'
                                  title='peel_ip::prelude::take_while_s'>take_while_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tap.html'
                                  title='peel_ip::prelude::tap'>tap</a></td>
                           <td class='docblock-short'>
                                <p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser&#39;s result without affecting it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.terminated.html'
                                  title='peel_ip::prelude::terminated'>terminated</a></td>
                           <td class='docblock-short'>
                                <p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.try_parse.html'
                                  title='peel_ip::prelude::try_parse'>try_parse</a></td>
                           <td class='docblock-short'>
                                <p>A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Done</code>,
and will do an early return for <code>Error</code> and <code>Incomplete</code>
this can provide more flexibility than <code>do_parse!</code> if needed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.tuple.html'
                                  title='peel_ip::prelude::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.u16.html'
                                  title='peel_ip::prelude::u16'>u16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.u32.html'
                                  title='peel_ip::prelude::u32'>u32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.u64.html'
                                  title='peel_ip::prelude::u64'>u64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.value.html'
                                  title='peel_ip::prelude::value'>value</a></td>
                           <td class='docblock-short'>
                                <p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.verify.html'
                                  title='peel_ip::prelude::verify'>verify</a></td>
                           <td class='docblock-short'>
                                <p><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verifcation function</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.wrap_sep.html'
                                  title='peel_ip::prelude::wrap_sep'>wrap_sep</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.ws.html'
                                  title='peel_ip::prelude::ws'>ws</a></td>
                           <td class='docblock-short'>
                                <p><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Connection.html'
                                  title='peel_ip::prelude::Connection'>Connection</a></td>
                           <td class='docblock-short'>
                                <p>Connection representation</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Data.html'
                                  title='peel_ip::prelude::Data'>Data</a></td>
                           <td class='docblock-short'>
                                <p>Identifies the connection</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Identifier.html'
                                  title='peel_ip::prelude::Identifier'>Identifier</a></td>
                           <td class='docblock-short'>
                                <p>Identifies the connection</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Ipv4Addr.html'
                                  title='peel_ip::prelude::Ipv4Addr'>Ipv4Addr</a></td>
                           <td class='docblock-short'>
                                <p>Representation of an IPv4 address.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Ipv6Addr.html'
                                  title='peel_ip::prelude::Ipv6Addr'>Ipv6Addr</a></td>
                           <td class='docblock-short'>
                                <p>Representation of an IPv6 address.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Path.html'
                                  title='peel_ip::prelude::Path'>Path</a></td>
                           <td class='docblock-short'>
                                <p>Global connection tracking structure</p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='enum' href='enum.IpAddr.html'
                                  title='peel_ip::prelude::IpAddr'>IpAddr</a></td>
                           <td class='docblock-short'>
                                <p>An IP address, either an IPv4 or IPv6 address.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='enum' href='enum.LogLevel.html'
                                  title='peel_ip::prelude::LogLevel'>LogLevel</a></td>
                           <td class='docblock-short'>
                                <p>An enum representing the available verbosity levels of the logging framework</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='enum' href='enum.PathErrorType.html'
                                  title='peel_ip::prelude::PathErrorType'>PathErrorType</a></td>
                           <td class='docblock-short'>
                                <p>Error codes as indicator what happened</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Error.html'
                                  title='peel_ip::prelude::Error'>Error</a></td>
                           <td class='docblock-short'>
                                <p>Base functionality for all errors in Rust.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.FromStr.html'
                                  title='peel_ip::prelude::FromStr'>FromStr</a></td>
                           <td class='docblock-short'>
                                <p>A trait to abstract the idea of creating a new instance of a type from a
string.</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.PathIp.html'
                                  title='peel_ip::prelude::PathIp'>PathIp</a></td>
                           <td class='docblock-short'>
                                <p>A shorthand for the <code>IpProtocol</code> based <code>Path</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.PeelIp.html'
                                  title='peel_ip::prelude::PeelIp'>PeelIp</a></td>
                           <td class='docblock-short'>
                                <p>A shorthand for the TCP/IP based <code>Peel</code></p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "peel_ip";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>