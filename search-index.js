var searchIndex = {};
searchIndex["peel_ip"] = {"doc":"# Packet parsing for the Internet Protocol Suite","items":[[0,"layer1","peel_ip","Data Link Layer packets",null,null],[0,"ethernet","peel_ip::layer1","Ethernet related packet processing",null,null],[3,"EthernetParser","peel_ip::layer1::ethernet","The Ethernet parser",null,null],[3,"EthernetPacket","","Representation of the Ethernet structure",null,null],[12,"dst","","Destination mac address",0,null],[12,"src","","Source mac address",0,null],[12,"ethertype","","EtherType of the packet",0,null],[3,"MacAddress","","Representation of a mac network address, usually in the format &quot;ff:ff:ff:ff:ff:ff&quot;",null,null],[12,"0","","",1,null],[12,"1","","",1,null],[12,"2","","",1,null],[12,"3","","",1,null],[12,"4","","",1,null],[12,"5","","",1,null],[4,"EtherType","","Supported `EtherType`",null,null],[13,"Ipv4","","Internet Protocol Version 4",2,null],[13,"Arp","","Address Resolution Protocol",2,null],[13,"Ipv6","","Internet Protocol Version 6",2,null],[11,"parse","","Parse an `EthernetPacket` from an `&amp;[u8]`",3,null],[11,"fmt","","",3,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"macaddress"}}],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"from_u16","","Convert a u16 to an `EtherType`. Returns None if the type is not supported or generally\ninvalid.",2,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[0,"arp","peel_ip::layer1","Address Resolution Protocol related packet processing",null,null],[3,"ArpParser","peel_ip::layer1::arp","The ARP parser",null,null],[3,"ArpPacket","","Representation of the Arp structure",null,null],[12,"hardware_type","","This field specifies the network protocol type. Example: Ethernet is 1.",4,null],[12,"protocol_type","","This field specifies the internetwork protocol for which the ARP request is\nintended. For IPv4, this has the value 0x0800. The permitted PTYPE values share a numbering\nspace with those for EtherType.",4,null],[12,"hardware_length","","Length (in octets) of a hardware address. Ethernet addresses size is 6.",4,null],[12,"protocol_length","","Length (in octets) of addresses used in the upper layer protocol. (The\nupper layer protocol specified in PTYPE.) IPv4 address size is 4.",4,null],[12,"operation","","Specifies the operation that the sender is performing: 1 for request, 2 for reply.",4,null],[12,"sender_hardware_address","","Media address of the sender.",4,null],[12,"sender_protocol_address","","Internetwork address of the sender.",4,null],[12,"target_hardware_address","","Media address of the intended receiver.",4,null],[12,"target_protocol_address","","Target protocol address: Internetwork address of the intended receiver.",4,null],[4,"ArpHardwareType","","Supported ARP Hardware Types",null,null],[13,"Ethernet","","Ethernet (10Mb)",5,null],[4,"ArpOperation","","Supported ARP operations",null,null],[13,"Request","","ARP requests",6,null],[13,"Reply","","ARP responses",6,null],[13,"ReverseRequest","","Reverse ARP requests",6,null],[13,"ReverseReply","","Reverse ARP responses",6,null],[11,"parse","","Parse an `ArpPacket` from an `&amp;[u8]`",7,null],[11,"fmt","","",7,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",5,null],[11,"eq","","",5,null],[11,"from_u16","","Convert a u16 to an `ArpHardwareType`. Returns None if the type is not supported or\ngenerally invalid.",5,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"fmt","","",6,null],[11,"eq","","",6,null],[11,"from_u16","","Convert a u16 to an `ArpOperation`. Returns None if the type is not supported or generally\ninvalid.",6,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[0,"layer2","peel_ip","Internet Layer packets",null,null],[0,"ipv4","peel_ip::layer2","Internet Protocol version 4 related packet processing",null,null],[3,"Ipv4Parser","peel_ip::layer2::ipv4","The IPv4 parser",null,null],[3,"Ipv4Packet","","Representation of an Internet Protocol version 4 packet",null,null],[12,"version","","Protocol version, should be &#39;4&#39;",8,null],[12,"ihl","","IP header length",8,null],[12,"tos","","Type of Service",8,null],[12,"length","","Total packet length including header",8,null],[12,"id","","Identification for the packet reassembly",8,null],[12,"flags","","IP header flags for fragmentation reassembly",8,null],[12,"fragment_offset","","Current fragmentation offset",8,null],[12,"ttl","","Time to live of the packet",8,null],[12,"protocol","","The transport protocol for the IP packet",8,null],[12,"checksum","","Header checksum",8,null],[12,"src","","Source address",8,null],[12,"dst","","Destination address",8,null],[4,"IpProtocol","","Current supported IPv4 protocols",null,null],[13,"Icmp","","Internet Control Message Protocol",9,null],[13,"IpIp","","IP encapsulation within IP",9,null],[13,"Tcp","","Transmission Control Protocol",9,null],[13,"Udp","","User Datagram Protocol",9,null],[13,"Ipv6","","IPv6 Encapsulation",9,null],[13,"Icmpv6","","Internet Control Message Protocol version 6",9,null],[11,"parse","","Parse an `Ipv4Packet` from an `&amp;[u8]`",10,null],[11,"fmt","","",10,null],[11,"fmt","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"hash","","",9,null],[11,"eq","","",9,null],[11,"from_u8","","Convert a u8 to an `IpProtocol`. Returns None if the type is not supported or generally\ninvalid.",9,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[0,"ipv6","peel_ip::layer2","Internet Protocol version 6 related packet processing",null,null],[3,"Ipv6Parser","peel_ip::layer2::ipv6","The IPv6 parser",null,null],[3,"Ipv6Packet","","Representation of an Internet Protocol version 6 packet",null,null],[12,"version","","The constant 6 (bit sequence 0110).",11,null],[12,"traffic_class","","The bits of this field hold two values. The 6 most-significant bits are used for\ndifferentiated services, which is used to classify packets. The remaining two bits are used\nfor ECN; priority values subdivide into ranges: traffic where the source provides\ncongestion control and non-congestion control traffic.",11,null],[12,"flow_label","","Originally created for giving real-time applications special service. The flow label when\nset to a non-zero value now serves as a hint to routers and switches with multiple outbound\npaths that these packets should stay on the same path so that they will not be reordered.\nIt has further been suggested that the flow label be used to help detect spoofed packets.",11,null],[12,"payload_length","","The size of the payload in octets, including any extension headers. The length is set to\nzero when a Hop-by-Hop extension header carries a Jumbo Payload option.",11,null],[12,"next_header","","Specifies the type of the next header. This field usually specifies the transport layer\nprotocol used by a packet&#39;s payload. When extension headers are present in the packet this\nfield indicates which extension header follows. The values are shared with those used for\nthe IPv4 protocol field, as both fields have the same function.",11,null],[12,"hop_limit","","Replaces the time to live field of IPv4. This value is decremented by one at each\nintermediate node visited by the packet. When the counter reaches 0 the packet is\ndiscarded.",11,null],[12,"src","","Source address",11,null],[12,"dst","","Destination address",11,null],[11,"parse","","Parse an `Ipv6Packet` from an `&amp;[u8]`",12,null],[11,"fmt","","",12,null],[11,"fmt","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[0,"icmp","peel_ip::layer2","Internet Control Message Protocol related packet processing",null,null],[3,"IcmpParser","peel_ip::layer2::icmp","The ICMP parser",null,null],[3,"IcmpPacket","","Representation of an Internet Control Message Protocol packet",null,null],[12,"message_type","","The ICMP type",13,null],[12,"code","","The message subtype",13,null],[12,"checksum","","Error checking data, calculated from the ICMP header and data, with value 0 substituted for\nthis field.",13,null],[12,"data","","Contents vary based on the type and code.",13,null],[3,"IcmpEcho","","ICMP echo request and replies",null,null],[12,"identifier","","Identifier",14,null],[12,"sequence_number","","Sequence Number",14,null],[12,"payload","","Optional payload",14,null],[4,"IcmpType","","Available ICMP control messages",null,null],[13,"EchoReply","","Echo reply used to ping",15,null],[13,"EchoRequest","","Echo request used to ping",15,null],[4,"IcmpData","","Representation of a certain ICMP message",null,null],[13,"Echo","","ICMP ping request and reply",16,null],[11,"parse","","Parse an `IcmpPacket` from an `&amp;[u8]`",17,null],[11,"fmt","","",17,null],[11,"fmt","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"fmt","","",15,null],[11,"eq","","",15,null],[11,"from_u8","","Convert a u8 to an `IcmpType`. Returns None if the type is not supported or generally\ninvalid.",15,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"fmt","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"fmt","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"parse","","Parse an ICMP echo request or reply",14,null],[0,"icmpv6","peel_ip::layer2","Internet Control Message Protocol version 6 related packet processing",null,null],[3,"Icmpv6Parser","peel_ip::layer2::icmpv6","The `ICMPv6` parser",null,null],[3,"Icmpv6Packet","","Representation of an Internet Control Message Protocol packet",null,null],[12,"message_type","","The ICMPv6 type",18,null],[12,"code","","The message subtype",18,null],[12,"checksum","","Error checking data, calculated from the ICMPv6 header and data, with value 0 substituted for\nthis field.",18,null],[12,"data","","Contents vary based on the type and code.",18,null],[4,"Icmpv6Type","","Available `ICMPv6` control messages",null,null],[13,"EchoReply","","Echo reply used to ping",19,null],[13,"EchoRequest","","Echo request used to ping",19,null],[4,"Icmpv6Data","","Representation of a certain `ICMPv6` message",null,null],[13,"Echo","","ICMPv6 ping request and reply",20,null],[11,"parse","","Parse an `Icmpv6Packet` from an `&amp;[u8]`",21,null],[11,"fmt","","",21,null],[11,"fmt","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"fmt","","",19,null],[11,"eq","","",19,null],[11,"from_u8","","Convert a u8 to an `Icmpv6Type`. Returns None if the type is not supported or generally\ninvalid.",19,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"fmt","","",20,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[0,"layer3","peel_ip","Transport Layer packets",null,null],[5,"track_connection","peel_ip::layer3","Track a connection based in the current parsing result and return the connection data",null,{"inputs":[{"name":"option"},{"name":"option"},{"name":"u16"},{"name":"u16"}],"output":{"name":"pathresult"}}],[0,"tcp","","Transmission Control Protocol related packet processing",null,null],[3,"TcpParser","peel_ip::layer3::tcp","The TCP parser",null,null],[3,"TcpPacket","","Representation of an User Datagram Protocol packet",null,null],[12,"header","","The header of the TCP packet",22,null],[12,"path_error","","Set to some error code if the connection tracking failed",22,null],[3,"TcpHeader","","Representation of a Transmission Control Protocol packet header",null,null],[12,"source_port","","Identifies the sending port",23,null],[12,"dest_port","","Identifies the receiving port",23,null],[12,"sequence_no","","If the SYN flag is set (1), then this is the initial sequence number. The sequence number\nof the actual first data byte and the acknowledged number in the corresponding ACK are then\nthis sequence number plus 1.\nIf the SYN flag is clear (0), then this is the accumulated sequence number of the first\ndata byte of this segment for the current session.",23,null],[12,"ack_no","","If the ACK flag is set then the value of this field is the next sequence number that the\nsender is expecting. This acknowledges receipt of all prior bytes (if any). The first ACK\nsent by each end acknowledges the other end&#39;s initial sequence number itself, but no data.",23,null],[12,"data_offset","","Specifies the size of the TCP header in 32-bit words. The minimum size header is 5 words\nand the maximum is 15 words thus giving the minimum size of 20 bytes and maximum of 60\nbytes, allowing for up to 40 bytes of options in the header. This field gets its name from\nthe fact that it is also the offset from the start of the TCP segment to the actual data.",23,null],[12,"reserved","","Kor future use and should be set to zero",23,null],[12,"flag_urg","","Indicates that the Urgent pointer field is significant",23,null],[12,"flag_ack","","Indicates that the Acknowledgment field is significant. All packets after the initial SYN\npacket sent by the client should have this flag set.",23,null],[12,"flag_psh","","Push function. Asks to push the buffered data to the receiving application.",23,null],[12,"flag_rst","","Reset the connection",23,null],[12,"flag_syn","","Synchronize sequence numbers. Only the first packet sent from each end should have this\nflag set. Some other flags and fields change meaning based on this flag, and some are only\nvalid for when it is set, and others when it is clear.",23,null],[12,"flag_fin","","No more data from sender",23,null],[12,"window","","The size of the receive window, which specifies the number of window size units (by\ndefault, bytes) (beyond the segment identified by the sequence number in the acknowledgment\nfield) that the sender of this segment is currently willing to receive (see Flow control\nand Window Scaling)",23,null],[12,"checksum","","The 16-bit checksum field is used for error-checking of the header and data",23,null],[12,"urgent_pointer","","If the URG flag is set, then this 16-bit field is an offset from the sequence number\nindicating the last urgent data byte",23,null],[12,"options","","The length of this field is determined by the data offset field.",23,null],[11,"parse","","Parse a `TcpPacket` from an `&amp;[u8]`",24,null],[11,"fmt","","",24,null],[11,"fmt","","",22,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"fmt","","",23,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[0,"tls","peel_ip::layer3","Transport layer security related packet processing",null,null],[3,"TlsParser","peel_ip::layer3::tls","The TLS parser",null,null],[3,"TlsPacket","","Representation of a Transport layer security packet",null,null],[12,"content_type","","Content type of the record",25,null],[12,"version","","TLS version of the record",25,null],[12,"length","","Record length",25,null],[3,"TlsRecordVersion","","TLS record protocol version",null,null],[12,"major","","Major part of the TLS version",26,null],[12,"minor","","Minor part of the TLS version",26,null],[4,"TlsRecordContentType","","TLS record protocol content type",null,null],[13,"ChangeCipherSpec","","Change Cipher Spec",27,null],[13,"Alert","","Alert",27,null],[13,"Handshake","","Handshake",27,null],[13,"ApplicationData","","Application Data",27,null],[13,"Heartbeat","","Heartbeat",27,null],[11,"parse","","Parse a `TlsPacket` from an `&amp;[u8]`",28,null],[11,"fmt","","",28,null],[11,"fmt","","",25,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"fmt","","",27,null],[11,"eq","","",27,null],[11,"from_u8","","Convert a u8 to an `TlsRecordContentType`. Returns None if the type is not supported or\ngenerally invalid.",27,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"fmt","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[0,"udp","peel_ip::layer3","User Datagram Protocol related packet processing",null,null],[3,"UdpParser","peel_ip::layer3::udp","The UDP parser",null,null],[3,"UdpPacket","","Representation of an User Datagram Protocol packet",null,null],[12,"header","","The header of the UDP packet",29,null],[12,"path_error","","Set to some error code if the connection tracking failed",29,null],[3,"UdpHeader","","Representation of an User Datagram Protocol packet header",null,null],[12,"source_port","","This field identifies the sender&#39;s port when meaningful and should be assumed to be the\nport to reply to if needed. If not used, then it should be zero. If the source host is the\nclient, the port number is likely to be an ephemeral port number. If the source host is the\nserver, the port number is likely to be a well-known port number.",30,null],[12,"dest_port","","This field identifies the receiver&#39;s port and is required. Similar to source port number,\nif the client is the destination host then the port number will likely be an ephemeral port\nnumber and if the destination host is the server then the port number will likely be a\nwell-known port number.",30,null],[12,"length","","A field that specifies the length in bytes of the UDP header and UDP data. The minimum\nlength is 8 bytes because that is the length of the header. The field size sets a\ntheoretical limit of 65,535 bytes (8 byte header + 65,527 bytes of data) for a UDP\ndatagram. The practical limit for the data length which is imposed by the underlying IPv4\nprotocol is 65,507 bytes (65,535 − 8 byte UDP header − 20 byte IP header).\nIn IPv6 jumbograms it is possible to have UDP packets of size greater than 65,535 bytes.\nRFC 2675 specifies that the length field is set to zero if the length of the UDP header\nplus UDP data is greater than 65,535.",30,null],[12,"checksum","","The checksum field may be used for error-checking of the header and data. This field is\noptional in IPv4, and mandatory in IPv6. The field carries all-zeros if unused.",30,null],[11,"parse","","Parse an `UdpPacket` from an `&amp;[u8]`",31,null],[11,"fmt","","",31,null],[11,"fmt","","",29,null],[11,"eq","","",29,null],[11,"ne","","",29,null],[11,"fmt","","",30,null],[11,"eq","","",30,null],[11,"ne","","",30,null],[0,"layer4","peel_ip","Application Layer packets",null,null],[0,"http","peel_ip::layer4","Hypertext Transfer Protocol related packet processing",null,null],[3,"HttpParser","peel_ip::layer4::http","The HTTP parser",null,null],[3,"HttpRequest","","A HTTP request representation",null,null],[12,"request_method","","The HTTP request method",32,null],[12,"version","","The HTTP version",32,null],[12,"path","","The HTTP path to be accessed",32,null],[12,"headers","","Available HTTP headers",32,null],[3,"HttpVersion","","HTTP protocol version",null,null],[12,"major","","Major part of the HTTP version",33,null],[12,"minor","","Minor part of the HTTP version",33,null],[3,"HttpHeader","","A generic HTTP header field",null,null],[12,"key","","A Key, like &quot;Host&quot;",34,null],[12,"value","","A value, like &quot;www.domain.com&quot;",34,null],[3,"HttpResponse","","A HTTP response representation",null,null],[12,"version","","The HTTP version",35,null],[12,"code","","The HTTP response status code",35,null],[12,"reason","","The reason behind the status code",35,null],[12,"headers","","Available HTTP headers",35,null],[4,"HttpPacket","","Representation of a Hypertext Transfer Protocol packet",null,null],[13,"Request","","Specifies a HTTP request",36,null],[13,"Response","","Specifies a HTTP response",36,null],[13,"Any","","Could be a plain or encrypted HTTP packet, but there is no further data parsable",36,null],[4,"HttpRequestMethod","","List of supported HTTP request methods",null,null],[13,"Get","","The GET method requests a representation of the specified resource.",37,null],[13,"Post","","The POST method requests that the server accept the entity enclosed in the request as a new\nsubordinate of the web resource identified by the URI.",37,null],[13,"Head","","The HEAD method asks for a response identical to that of a GET request, but without the\nresponse body.",37,null],[13,"Put","","The PUT method requests that the enclosed entity be stored under the supplied URI.",37,null],[13,"Delete","","The DELETE method deletes the specified resource.",37,null],[13,"Trace","","The TRACE method echoes the received request so that a client can see what (if any) changes\nor additions have been made by intermediate servers.",37,null],[13,"Options","","The OPTIONS method returns the HTTP methods that the server supports for the specified URL.",37,null],[13,"Connect","","The CONNECT method converts the request connection to a transparent TCP/IP tunnel, usually\nto facilitate SSL-encrypted communication (HTTPS) through an unencrypted HTTP proxy.",37,null],[13,"Patch","","The PATCH method applies partial modifications to a resource.",37,null],[11,"parse","","Parse a `HttpPacket` from an `&amp;[u8]`",38,null],[11,"fmt","","",38,null],[11,"fmt","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"fmt","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"fmt","","",37,null],[11,"eq","","",37,null],[11,"fmt","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"fmt","","",34,null],[11,"eq","","",34,null],[11,"ne","","",34,null],[11,"fmt","","",35,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[0,"ntp","peel_ip::layer4","Network Time Protocol related packet processing",null,null],[3,"NtpParser","peel_ip::layer4::ntp","The UDP parser",null,null],[3,"NtpPacket","","Representation of a Network Time Protocol packet",null,null],[12,"li","","Leap Indicator (2 Bit)\nThis field is used to warn of an impending leap second",39,null],[12,"version","","NTP version number (3 Bit)",39,null],[12,"mode","","Mode (3 Bit)",39,null],[12,"stratum","","Stratum level of the local clock",39,null],[12,"poll","","The maximum interval between messages in seconds to the nearest power of two",39,null],[12,"precision","","Precision of the local clock in seconds to the nearest power of two",39,null],[12,"root_delay","","The total round trip delay to the primary reference source, in seconds with the fraction\npoint between bits 15 and 16. Positive and negative values are valid",39,null],[12,"root_dispersion","","The maximum error relative to the primary reference source in seconds with the fraction\npoint between bits 15 and 16. Only positive values greater than zero are valid",39,null],[12,"ref_id","","Reference clock identifier. Used to identify the particular reference clock.",39,null],[12,"ts_ref","","Reference timestamp. The local time at which the local clock was last set or corrected.",39,null],[12,"ts_orig","","Originate timestamp. The local time when the client sent the request.",39,null],[12,"ts_recv","","Receive timestamp. The local time when the request was received by the server.",39,null],[12,"ts_xmit","","Transmit timestamp. The local time when the reply was sent from the server.",39,null],[12,"auth","","Authenticator. (0 or 96 Bit) See section 7.5 of [RFC5905] and [RFC7822]",39,null],[11,"parse","","Parse a `NtpPacket` from an `&amp;[u8]`",40,null],[11,"fmt","","",40,null],[11,"fmt","","",39,null],[11,"eq","","",39,null],[11,"ne","","",39,null],[0,"prelude","peel_ip","Provides sensible imports for packet parsers",null,null],[0,"fmt","peel_ip::prelude","Utilities for formatting and printing `String`s",null,null],[5,"format","peel_ip::prelude::fmt","The format function takes a precompiled format string and a list of\narguments, to return the resulting formatted string.",null,{"inputs":[{"name":"arguments"}],"output":{"name":"string"}}],[8,"Debug","","Format trait for the `?` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",41,null],[8,"Binary","","Format trait for the `b` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",42,null],[3,"Error","","The error type which is returned from formatting a message into a stream.",null,null],[3,"DebugStruct","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"UpperHex","","Format trait for the `X` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",43,null],[8,"Pointer","","Format trait for the `p` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",44,null],[3,"DebugList","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"Octal","","Format trait for the `o` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",45,null],[8,"UpperExp","","Format trait for the `E` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",46,null],[3,"DebugSet","","A struct to help with `fmt::Debug` implementations.",null,null],[6,"Result","","The type returned by formatter methods.",null,null],[8,"LowerHex","","Format trait for the `x` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",47,null],[3,"DebugTuple","","A struct to help with `fmt::Debug` implementations.",null,null],[5,"write","","The `write` function takes an output stream, a precompiled format string,\nand a list of arguments. The arguments will be formatted according to the\nspecified format string into the output stream provided.",null,{"inputs":[{"name":"write"},{"name":"arguments"}],"output":{"name":"result"}}],[3,"Arguments","","This structure represents a safely precompiled version of a format string\nand its arguments. This cannot be generated at runtime because it cannot\nsafely be done so, so no constructors are given and the fields are private\nto prevent modification.",null,null],[8,"Write","","A collection of methods that are required to format a message into a stream.",null,null],[10,"write_str","","Writes a slice of bytes into this writer, returning whether the write\nsucceeded.",48,null],[11,"write_char","","Writes a `char` into this writer, returning whether the write succeeded.",48,null],[11,"write_fmt","","Glue for usage of the `write!` macro with implementors of this trait.",48,null],[8,"LowerExp","","Format trait for the `e` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",49,null],[3,"DebugMap","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"Display","","Format trait for an empty format, `{}`.",null,null],[10,"fmt","","Formats the value using the given formatter.",50,null],[3,"Formatter","","A struct to represent both where to emit formatting strings to and how they\nshould be formatted. A mutable version of this is passed to all formatting\ntraits.",null,null],[8,"Error","peel_ip::prelude","Base functionality for all errors in Rust.",null,null],[10,"description","","A short description of the error.",51,null],[11,"cause","","The lower-level cause of this error, if any.",51,null],[0,"str","","Unicode string slices.",null,null],[3,"EncodeUtf16","peel_ip::prelude::str","External iterator for a string&#39;s UTF-16 code units.",null,null],[3,"SplitTerminator","","Created with the method [`split_terminator()`].",null,null],[3,"Chars","","Iterator for the char (representing *Unicode Scalar Values*) of a string",null,null],[3,"RSplit","","Created with the method [`rsplit()`].",null,null],[3,"RMatchIndices","","Created with the method [`rmatch_indices()`].",null,null],[3,"SplitWhitespace","","An iterator over the non-whitespace substrings of a string,\nseparated by any amount of whitespace.",null,null],[3,"LinesAny","","Created with the method [`lines_any()`].",null,null],[3,"RSplitN","","Created with the method [`rsplitn()`].",null,null],[3,"ParseBoolError","","An error returned when parsing a `bool` from a string fails.",null,null],[5,"from_utf8","","Converts a slice of bytes to a string slice.",null,null],[3,"SplitN","","Created with the method [`splitn()`].",null,null],[0,"pattern","","The string Pattern API.",null,null],[8,"Pattern","peel_ip::prelude::str::pattern","A string pattern.",null,null],[16,"Searcher","","Associated searcher for this pattern",52,null],[10,"into_searcher","","Constructs the associated searcher from\n`self` and the `haystack` to search in.",52,null],[11,"is_contained_in","","Checks whether the pattern matches anywhere in the haystack",52,null],[11,"is_prefix_of","","Checks whether the pattern matches at the front of the haystack",52,null],[11,"is_suffix_of","","Checks whether the pattern matches at the back of the haystack",52,null],[4,"SearchStep","","Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.",null,null],[13,"Match","","Expresses that a match of the pattern has been found at\n`haystack[a..b]`.",53,null],[13,"Reject","","Expresses that `haystack[a..b]` has been rejected as a possible match\nof the pattern.",53,null],[13,"Done","","Expresses that every byte of the haystack has been visted, ending\nthe iteration.",53,null],[8,"Searcher","","A searcher for a string pattern.",null,null],[10,"haystack","","Getter for the underlaying string to be searched in",54,null],[10,"next","","Performs the next search step starting from the front.",54,null],[11,"next_match","","Find the next `Match` result. See `next()`",54,null],[11,"next_reject","","Find the next `Reject` result. See `next()`",54,null],[8,"ReverseSearcher","","A reverse searcher for a string pattern.",null,null],[10,"next_back","","Performs the next search step starting from the back.",55,null],[11,"next_match_back","","Find the next `Match` result. See `next_back()`",55,null],[11,"next_reject_back","","Find the next `Reject` result. See `next_back()`",55,null],[8,"DoubleEndedSearcher","","A marker trait to express that a `ReverseSearcher`\ncan be used for a `DoubleEndedIterator` implementation.",null,null],[3,"CharSearcher","","Associated type for `&lt;char as Pattern&lt;&#39;a&gt;&gt;::Searcher`.",null,null],[3,"CharSliceSearcher","","Associated type for `&lt;&amp;[char] as Pattern&lt;&#39;a&gt;&gt;::Searcher`.",null,null],[3,"CharPredicateSearcher","","Associated type for `&lt;F as Pattern&lt;&#39;a&gt;&gt;::Searcher`.",null,null],[3,"StrSearcher","","Associated type for `&lt;&amp;str as Pattern&lt;&#39;a&gt;&gt;::Searcher`.",null,null],[3,"MatchIndices","peel_ip::prelude::str","Created with the method [`match_indices()`].",null,null],[3,"Lines","","Created with the method [`lines()`].",null,null],[3,"RMatches","","Created with the method [`rmatches()`].",null,null],[3,"Bytes","","External iterator for a string&#39;s bytes.\nUse with the `std::iter` module.",null,null],[3,"Split","","Created with the method [`split()`].",null,null],[5,"from_utf8_unchecked","","Converts a slice of bytes to a string slice without checking\nthat the string contains valid UTF-8.",null,null],[3,"Utf8Error","","Errors which can occur when attempting to interpret a sequence of `u8`\nas a string.",null,null],[3,"Matches","","Created with the method [`matches()`].",null,null],[3,"CharIndices","","Iterator for a string&#39;s characters and their byte offsets.",null,null],[8,"FromStr","","A trait to abstract the idea of creating a new instance of a type from a\nstring.",null,null],[16,"Err","","The associated error which can be returned from parsing.",56,null],[10,"from_str","","Parses a string `s` to return a value of this type.",56,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[3,"RSplitTerminator","","Created with the method [`rsplit_terminator()`].",null,null],[8,"FromStr","peel_ip::prelude","A trait to abstract the idea of creating a new instance of a type from a\nstring.",null,null],[16,"Err","","The associated error which can be returned from parsing.",56,null],[10,"from_str","","Parses a string `s` to return a value of this type.",56,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[4,"IpAddr","","An IP address, either an IPv4 or IPv6 address.",null,null],[13,"V4","","Representation of an IPv4 address.",57,null],[13,"V6","","Representation of an IPv6 address.",57,null],[3,"Ipv4Addr","","Representation of an IPv4 address.",null,null],[3,"Ipv6Addr","","Representation of an IPv6 address.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",58,null],[13,"Warn","","The &quot;warn&quot; level.",58,null],[13,"Info","","The &quot;info&quot; level.",58,null],[13,"Debug","","The &quot;debug&quot; level.",58,null],[13,"Trace","","The &quot;trace&quot; level.",58,null],[3,"Path","","Global connection tracking structure",null,null],[12,"timeout","","A general connection timeout, per default 10 minutes",59,null],[12,"max_connections","","Maximum amount of flows within the HashMap, per default 1 million",59,null],[3,"Connection","","Connection representation",null,null],[12,"identifier","","Identifies the connection",60,null],[12,"data","","Data which can be used for the connection",60,null],[3,"Data","","Identifies the connection",null,null],[12,"custom","","Data from the user",61,null],[3,"Identifier","","Identifies the connection",null,null],[12,"lower","","Lower subscriber",62,null],[12,"greater","","Greater subscriber",62,null],[12,"key","","Usually the communication protocol of the subscribers",62,null],[4,"PathErrorType","","Error codes as indicator what happened",null,null],[13,"PacketCounterOverflow","","The internal packet counter is overflown",63,null],[13,"Timeout","","Connection removed because of a timeout",63,null],[13,"Internal","","Internal error which should not happen at all",63,null],[6,"PeelIp","","A shorthand for the TCP/IP based `Peel`",null,null],[6,"PathIp","","A shorthand for the `IpProtocol` based `Path`",null,null],[14,"preceded","","`preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\npreceded(opening, X) returns X",null,null],[14,"take_until_and_consume_s","","`take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and consumes it",null,null],[14,"permutation","","",null,null],[14,"apply_m","","emulate function currying for method calls on structs\n`apply_m!(self.my_function, arg1, arg2, ...)` becomes `self.my_function(input, arg1, arg2, ...)`",null,null],[14,"tag_no_case_s","","`tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ndeclares a case-insensitive string as a suite to recognize",null,null],[14,"value","","`value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"take_while1_s","","`take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest (non empty) list of characters until the provided function fails.",null,null],[14,"is_not","","`is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"consumer_from_parser","","",null,null],[14,"try_parse","","A bit like `std::try!`, this macro will return the remaining input and parsed value if the child parser returned `Done`,\nand will do an early return for `Error` and `Incomplete`\nthis can provide more flexibility than `do_parse!` if needed",null,null],[14,"none_of","","matches anything but the provided characters",null,null],[14,"i64","","if the parameter is nom::Endianness::Big, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[14,"i32","","if the parameter is nom::Endianness::Big, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"many_till","","`many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;`\nApplies the first parser until the second applies. Returns a tuple containing the list\nof results from the first in a Vec and the result of the second.",null,null],[14,"eof","","`eof!(i)` returns `i` if it is at the end of input data",null,null],[14,"wrap_sep","","",null,null],[14,"return_error","","Prevents backtracking if the child parser fails",null,null],[14,"count","","`count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the child parser a specified number of times",null,null],[14,"alt","","`alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\ntry a list of parsers, return the result of the first successful one",null,null],[14,"length_count","","`length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"apply","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"delimited","","`delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\ndelimited(opening, X, closing) returns X",null,null],[14,"u32","","if the parameter is nom::Endianness::Big, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"take_until","","`take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds the specified tag",null,null],[14,"take_until_either_and_consume","","`take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds any of the specified characters, and consume it",null,null],[14,"named_args","","Makes a function from a parser combination with arguments.",null,null],[14,"many_m_n","","`many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser between m and n times (n included) and returns the list of\nresults in a Vec",null,null],[14,"sep","","sep is the parser rewriting macro for whitespace separated formats",null,null],[14,"take_till","","`take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function succeeds",null,null],[14,"tuple","","`tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;`\nchains parsers and assemble the sub results in a tuple.",null,null],[14,"length_bytes","","`length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nGets a number from the first parser, then extracts that many bytes from the\nremaining stream",null,null],[14,"take_until_s","","`take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and leaves it in the remaining input",null,null],[14,"parse_to","","`parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;`\nuses the `parse` method from `std::str::FromStr` to convert the current\ninput to the specified type",null,null],[14,"error_code","","creates a parse error from a `nom::ErrorKind`",null,null],[14,"take_s","","`take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming the specified number of characters",null,null],[14,"take_while","","`take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1","","`take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"escaped_transform","","`escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"take_till_s","","`take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function succeeds",null,null],[14,"switch","","`switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchoose the next parser depending on the result of the first one, if successful,\nand returns the result of the second parser",null,null],[14,"chain","","[DEPRECATED] `chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchains parsers and assemble the results through a closure",null,null],[14,"alt_complete","","This is a combination of the `alt!` and `complete!` combinators. Rather\nthan returning `Incomplete` on partial input, `alt_complete!` will try the\nnext alternative in the chain. You should use this only if you know you\nwill not receive partial input for the rules you&#39;re trying to match (this\nis almost always the case for parsing programming languages).",null,null],[14,"fold_many_m_n","","`fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser between m and n times (n included) and folds the list of return value",null,null],[14,"tag_s","","`tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ndeclares a string as a suite to recognize",null,null],[14,"u64","","if the parameter is nom::Endianness::Big, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"is_a","","`is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"expr_res","","`expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Result&lt;T,E&gt; and returns a IResult::Done(I,T) if Ok",null,null],[14,"opt","","`opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"map_opt","","`map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning an Option on the output of a parser",null,null],[14,"cond","","`cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"recognize","","`recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nif the child parser was successful, return the consumed input as produced value",null,null],[14,"complete","","replaces a `Incomplete` returned by the child parser\nwith an `Error`",null,null],[14,"add_return_error","","Add an error if the child parser fails",null,null],[14,"named","","Makes a function from a parser combination",null,null],[14,"tag","","`tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ndeclares a byte array as a suite to recognize",null,null],[14,"dbg_dmp","","Prints a message and the input if the parser fails",null,null],[14,"method","","Makes a method from a parser combination",null,null],[14,"dbg","","Prints a message if the parser fails",null,null],[14,"many0","","`many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"one_of","","matches one of the provided characters",null,null],[14,"i16","","if the parameter is nom::Endianness::Big, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"peek","","`peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result without consuming the input",null,null],[14,"cond_with_error","","`cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"length_data","","`length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O`",null,null],[14,"expr_opt","","`expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Option&lt;T&gt; and returns a IResult::Done(I,T) if Some",null,null],[14,"verify","","`verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns the result of the child parser if it satisfies a verifcation function",null,null],[14,"separated_list","","`separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"take","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"tag_bits","","matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified",null,null],[14,"not","","`not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result only if the embedded parser returns Error or Incomplete\ndoes not consume the input",null,null],[14,"take_str","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;`\nsame as take! but returning a &amp;str",null,null],[14,"separated_pair","","`separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"closure","","Wraps a parser in a closure",null,null],[14,"error_node_position","","creates a parse error from a `nom::ErrorKind`,\nthe position in the input and the next error in\nthe parsing tree.\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"flat_map","","`flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"char","","matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;",null,null],[14,"fix_error","","translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type",null,null],[14,"bits","","`bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;`\ntransforms its byte slice input into a bit stream for the underlying parsers",null,null],[14,"error_node","","creates a parse error from a `nom::ErrorKind`\nand the next error in the parsing tree.\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"is_not_s","","`is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that do not appear in the provided array",null,null],[14,"call_m","","Used to called methods then move self back into self",null,null],[14,"escaped","","`escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"take_while_s","","`take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function fails.",null,null],[14,"call","","Used to wrap common expressions and function as macros",null,null],[14,"fold_many1","","`fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 1 or more times and folds the list of return values",null,null],[14,"fold_many0","","`fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 0 or more times and folds the list of return values",null,null],[14,"tag_no_case","","`tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ndeclares a case insensitive ascii string as a suite to recognize",null,null],[14,"tap","","`tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;`\nallows access to the parser&#39;s result without affecting it",null,null],[14,"length_value","","`length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\ngets a number from the first parser, takes a subslice of the input of that size,\nthen applies the second parser on that subslice. If the second parser returns\n`Incomplete`, `length_value` will return an error",null,null],[14,"named_attr","","Makes a function from a parser combination, with attributes",null,null],[14,"ws","","`ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`",null,null],[14,"separated_nonempty_list","","`separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_nonempty_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"take_until_either","","`take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`",null,null],[14,"opt_res","","`opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"take_bits","","`take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;`\ngenerates a parser consuming the specified number of bits.",null,null],[14,"count_fixed","","`count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;`\nApplies the child parser a fixed number of times and returns a fixed size array\nThe type must be specified and it must be `Copy`",null,null],[14,"terminated","","`terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nterminated(X, closing) returns X",null,null],[14,"u16","","if the parameter is nom::Endianness::Big, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"map_res","","`map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning a Result on the output of a parser",null,null],[14,"take_until_and_consume","","`take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"map","","`map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function on the result of a parser",null,null],[14,"do_parse","","`do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;`\ndo_parse applies sub parsers in a sequence.\nit can store intermediary results and make them available\nfor later parsers",null,null],[14,"pair","","`pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\npair(X,Y), returns (x,y)",null,null],[14,"many1","","`many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"cond_reduce","","`cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nConditional combinator with error",null,null],[14,"eat_separator","","helper macros to build a separator parser",null,null],[14,"error_position","","creates a parse error from a `nom::ErrorKind`\nand the position in the input\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"is_a_s","","`is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that appear in the provided array",null,null],[8,"NewPeelIp","peel_ip","Trait for default parser tree generation",null,null],[11,"default","","Get the default parser tree",64,{"inputs":[],"output":{"name":"peelip"}}],[11,"fmt","peel_ip::prelude","",60,null],[11,"fmt","","",62,null],[11,"eq","","",63,null],[11,"eq","","",59,null],[11,"ne","","",59,null],[11,"eq","","",60,null],[11,"ne","","",60,null],[11,"eq","","",62,null],[11,"ne","","",62,null],[11,"eq","","",61,null],[11,"ne","","",61,null],[11,"clone","","",59,null],[11,"clone","","",62,null],[11,"clone","","",61,null],[11,"hash","","",62,null],[11,"fmt","","",63,null],[11,"fmt","","",59,null],[11,"fmt","","",60,null],[11,"fmt","","",62,null],[11,"fmt","","",61,null],[11,"len","peel_ip::prelude::str","",65,null],[11,"is_empty","","",65,null],[11,"next_back","peel_ip::prelude::str::pattern","",66,null],[11,"next_match_back","","",66,null],[11,"next_reject_back","","",66,null],[11,"next_back","","",67,null],[11,"next_match_back","","",67,null],[11,"next_reject_back","","",67,null],[11,"next_back","","",68,null],[11,"next_match_back","","",68,null],[11,"next_reject_back","","",68,null],[11,"next_back","","",69,null],[11,"next_match_back","","",69,null],[11,"fmt","","",68,null],[11,"fmt","peel_ip::prelude::fmt","",70,null],[11,"fmt","peel_ip::prelude::str::pattern","",53,null],[11,"fmt","","",66,null],[11,"fmt","","",67,null],[11,"fmt","","",69,null],[11,"fmt","peel_ip::prelude::str","",71,null],[11,"fmt","","",72,null],[11,"fmt","","",73,null],[11,"fmt","","",74,null],[11,"fmt","","",65,null],[11,"fmt","","",75,null],[11,"fmt","","",76,null],[11,"fmt","","",77,null],[11,"fmt","","",78,null],[11,"fmt","","",79,null],[11,"fmt","","",80,null],[11,"fmt","","",81,null],[11,"fmt","","",82,null],[11,"fmt","","",83,null],[11,"fmt","","",84,null],[11,"fmt","","",85,null],[11,"fmt","","",86,null],[11,"fmt","peel_ip::prelude::fmt","",87,null],[11,"write_str","","",88,null],[11,"write_char","","",88,null],[11,"write_fmt","","",88,null],[11,"cmp","","",87,null],[11,"next","peel_ip::prelude::str","",73,null],[11,"count","","",73,null],[11,"size_hint","","",73,null],[11,"last","","",73,null],[11,"next","","",74,null],[11,"count","","",74,null],[11,"size_hint","","",74,null],[11,"last","","",74,null],[11,"next","","",65,null],[11,"size_hint","","",65,null],[11,"count","","",65,null],[11,"last","","",65,null],[11,"nth","","",65,null],[11,"next","","",85,null],[11,"size_hint","","",85,null],[11,"next","","",86,null],[11,"size_hint","","",86,null],[11,"next","","",75,null],[11,"next","","",76,null],[11,"next","","",77,null],[11,"next","","",78,null],[11,"next","","",79,null],[11,"next","","",80,null],[11,"next","","",81,null],[11,"next","","",82,null],[11,"next","","",83,null],[11,"next","","",84,null],[11,"partial_cmp","peel_ip::prelude::fmt","",87,null],[11,"eq","peel_ip::prelude::str::pattern","",53,null],[11,"ne","","",53,null],[11,"eq","peel_ip::prelude::str","",71,null],[11,"ne","","",71,null],[11,"eq","","",72,null],[11,"ne","","",72,null],[11,"eq","peel_ip::prelude::fmt","",87,null],[11,"default","","",87,{"inputs":[],"output":{"name":"error"}}],[11,"clone","peel_ip::prelude::str::pattern","",53,null],[11,"clone","","",66,null],[11,"clone","","",67,null],[11,"clone","","",68,null],[11,"clone","","",69,null],[11,"clone","peel_ip::prelude::str","",71,null],[11,"clone","","",72,null],[11,"clone","","",73,null],[11,"clone","","",74,null],[11,"clone","","",65,null],[11,"clone","","",75,null],[11,"clone","","",76,null],[11,"clone","","",77,null],[11,"clone","","",78,null],[11,"clone","","",79,null],[11,"clone","","",80,null],[11,"clone","","",81,null],[11,"clone","","",82,null],[11,"clone","","",83,null],[11,"clone","","",84,null],[11,"clone","","",85,null],[11,"clone","","",86,null],[11,"clone","peel_ip::prelude::fmt","",87,null],[11,"clone","","",70,null],[11,"next_back","peel_ip::prelude::str","",73,null],[11,"next_back","","",74,null],[11,"next_back","","",65,null],[11,"next_back","","",85,null],[11,"next_back","","",86,null],[11,"next_back","","",75,null],[11,"next_back","","",76,null],[11,"next_back","","",77,null],[11,"next_back","","",78,null],[11,"next_back","","",81,null],[11,"next_back","","",82,null],[11,"next_back","","",83,null],[11,"next_back","","",84,null],[11,"fmt","","",71,null],[11,"fmt","","",72,null],[11,"fmt","peel_ip::prelude::fmt","",70,null],[11,"fmt","","",87,null],[11,"haystack","peel_ip::prelude::str::pattern","",66,null],[11,"next","","",66,null],[11,"next_match","","",66,null],[11,"next_reject","","",66,null],[11,"haystack","","",67,null],[11,"next","","",67,null],[11,"next_match","","",67,null],[11,"next_reject","","",67,null],[11,"haystack","","",68,null],[11,"next","","",68,null],[11,"next_match","","",68,null],[11,"next_reject","","",68,null],[11,"haystack","","",69,null],[11,"next","","",69,null],[11,"next_match","","",69,null],[11,"hash","peel_ip::prelude::fmt","",87,null],[11,"next_back","peel_ip::prelude::str","",89,null],[11,"next","","",89,null],[11,"fmt","peel_ip::prelude","",90,null],[11,"fmt","","",91,null],[11,"fmt","","",57,null],[11,"partial_cmp","","",90,null],[11,"partial_cmp","","",91,null],[11,"partial_cmp","","",57,null],[11,"lt","","",57,null],[11,"le","","",57,null],[11,"gt","","",57,null],[11,"ge","","",57,null],[11,"description","peel_ip::prelude::str","",71,null],[11,"description","","",72,null],[11,"description","peel_ip::prelude::fmt","",87,null],[11,"hash","peel_ip::prelude","",90,null],[11,"hash","","",91,null],[11,"hash","","",57,null],[11,"fmt","","",57,null],[11,"fmt","","",90,null],[11,"fmt","","",91,null],[11,"from","","",90,{"inputs":[{"name":"u32"}],"output":{"name":"ipv4addr"}}],[11,"from","","",90,null],[11,"from","","",91,null],[11,"clone","","",90,null],[11,"clone","","",91,null],[11,"clone","","",57,null],[11,"cmp","","",90,null],[11,"cmp","","",91,null],[11,"cmp","","",57,null],[11,"eq","","",90,null],[11,"eq","","",91,null],[11,"eq","","",57,null],[11,"ne","","",57,null],[11,"from_str","","",57,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str","","",90,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str","","",91,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",58,null],[11,"cmp","","",58,null],[11,"eq","","",58,null],[11,"eq","","",58,null],[11,"clone","","",58,null],[11,"fmt","","",58,null],[11,"partial_cmp","","",58,null],[11,"partial_cmp","","",58,null],[11,"from_str","","",58,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"clone","peel_ip::prelude::str","",92,null],[11,"next","","",92,null],[11,"size_hint","","",92,null],[11,"field","peel_ip::prelude::fmt","Adds a new field to the generated struct output.",93,null],[11,"finish","","Finishes output and returns any error encountered.",93,null],[11,"entry","","Adds a new entry to the list output.",94,null],[11,"entries","","Adds the contents of an iterator of entries to the list output.",94,null],[11,"finish","","Finishes output and returns any error encountered.",94,null],[11,"entry","","Adds a new entry to the set output.",95,null],[11,"entries","","Adds the contents of an iterator of entries to the set output.",95,null],[11,"finish","","Finishes output and returns any error encountered.",95,null],[11,"field","","Adds a new field to the generated tuple struct output.",96,null],[11,"finish","","Finishes output and returns any error encountered.",96,null],[11,"entry","","Adds a new entry to the map output.",97,null],[11,"entries","","Adds the contents of an iterator of entries to the map output.",97,null],[11,"finish","","Finishes output and returns any error encountered.",97,null],[11,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a str. The str should *not* contain the sign for the\ninteger, that will be added by this method.",88,null],[11,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",88,null],[11,"write_str","","Writes some data to the underlying buffer contained within this\nformatter.",88,null],[11,"write_fmt","","Writes some formatted information into this instance",88,null],[11,"flags","","Flags for formatting (packed version of rt::Flag)",88,null],[11,"fill","","Character used as &#39;fill&#39; whenever there is alignment",88,null],[11,"align","","Flag indicating what form of alignment was requested",88,null],[11,"width","","Optionally specified integer width that the output should be",88,null],[11,"precision","","Optionally specified precision for numeric types",88,null],[11,"sign_plus","","Determines if the `+` flag was specified.",88,null],[11,"sign_minus","","Determines if the `-` flag was specified.",88,null],[11,"alternate","","Determines if the `#` flag was specified.",88,null],[11,"sign_aware_zero_pad","","Determines if the `0` flag was specified.",88,null],[11,"debug_struct","","Creates a `DebugStruct` builder designed to assist with creation of\n`fmt::Debug` implementations for structs.",88,null],[11,"debug_tuple","","Creates a `DebugTuple` builder designed to assist with creation of\n`fmt::Debug` implementations for tuple structs.",88,null],[11,"debug_list","","Creates a `DebugList` builder designed to assist with creation of\n`fmt::Debug` implementations for list-like structures.",88,null],[11,"debug_set","","Creates a `DebugSet` builder designed to assist with creation of\n`fmt::Debug` implementations for set-like structures.",88,null],[11,"debug_map","","Creates a `DebugMap` builder designed to assist with creation of\n`fmt::Debug` implementations for map-like structures.",88,null],[11,"is","peel_ip::prelude","Returns true if the boxed type is the same as `T`",51,null],[11,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn&#39;t.",51,null],[11,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn&#39;t.",51,null],[11,"is","","Forwards to the method defined on the type `Any`.",51,null],[11,"downcast_ref","","Forwards to the method defined on the type `Any`.",51,null],[11,"downcast_mut","","Forwards to the method defined on the type `Any`.",51,null],[11,"is","","Forwards to the method defined on the type `Any`.",51,null],[11,"downcast_ref","","Forwards to the method defined on the type `Any`.",51,null],[11,"downcast_mut","","Forwards to the method defined on the type `Any`.",51,null],[11,"downcast","","Attempt to downcast the box to a concrete type.",51,{"inputs":[{"name":"box"}],"output":{"name":"result"}}],[11,"downcast","","Attempt to downcast the box to a concrete type.",51,{"inputs":[{"name":"box"}],"output":{"name":"result"}}],[11,"downcast","","Attempt to downcast the box to a concrete type.",51,{"inputs":[{"name":"box"}],"output":{"name":"result"}}],[11,"as_str","peel_ip::prelude::str","View the underlying data as a subslice of the original data.",73,null],[11,"valid_up_to","","Returns the index in the given string up to which valid UTF-8 was\nverified.",72,null],[11,"as_str","","View the underlying data as a subslice of the original data.",74,null],[11,"is_unspecified","peel_ip::prelude","Returns true for the special &#39;unspecified&#39; address ([IPv4], [IPv6]).",57,null],[11,"is_loopback","","Returns true if this is a loopback address ([IPv4], [IPv6]).",57,null],[11,"is_global","","Returns true if the address appears to be globally routable ([IPv4], [IPv6]).",57,null],[11,"is_multicast","","Returns true if this is a multicast address ([IPv4], [IPv6]).",57,null],[11,"is_documentation","","Returns true if this address is in a range designated for documentation ([IPv4], [IPv6]).",57,null],[11,"is_ipv4","","Returns true if this address is a valid IPv4 address, false if it&#39;s a valid IPv6 address.",57,null],[11,"is_ipv6","","Returns true if this address is a valid IPv6 address, false if it&#39;s a valid IPv4 address.",57,null],[11,"new","","Creates a new IPv4 address from four eight-bit octets.",90,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"}],"output":{"name":"ipv4addr"}}],[11,"octets","","Returns the four eight-bit integers that make up this address.",90,null],[11,"is_unspecified","","Returns true for the special &#39;unspecified&#39; address (0.0.0.0).",90,null],[11,"is_loopback","","Returns true if this is a loopback address (127.0.0.0/8).",90,null],[11,"is_private","","Returns true if this is a private address.",90,null],[11,"is_link_local","","Returns true if the address is link-local (169.254.0.0/16).",90,null],[11,"is_global","","Returns true if the address appears to be globally routable.\nSee [iana-ipv4-special-registry][ipv4-sr].",90,null],[11,"is_multicast","","Returns true if this is a multicast address (224.0.0.0/4).",90,null],[11,"is_broadcast","","Returns true if this is a broadcast address (255.255.255.255).",90,null],[11,"is_documentation","","Returns true if this address is in a range designated for documentation.",90,null],[11,"to_ipv6_compatible","","Converts this address to an IPv4-compatible IPv6 address.",90,null],[11,"to_ipv6_mapped","","Converts this address to an IPv4-mapped IPv6 address.",90,null],[11,"new","","Creates a new IPv6 address from eight 16-bit segments.",91,{"inputs":[{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"}],"output":{"name":"ipv6addr"}}],[11,"segments","","Returns the eight 16-bit segments that make up this address.",91,null],[11,"is_unspecified","","Returns true for the special &#39;unspecified&#39; address (::).",91,null],[11,"is_loopback","","Returns true if this is a loopback address (::1).",91,null],[11,"is_global","","Returns true if the address appears to be globally routable.",91,null],[11,"is_unique_local","","Returns true if this is a unique local address (fc00::/7).",91,null],[11,"is_unicast_link_local","","Returns true if the address is unicast and link-local (fe80::/10).",91,null],[11,"is_unicast_site_local","","Returns true if this is a deprecated unicast site-local address\n(fec0::/10).",91,null],[11,"is_documentation","","Returns true if this is an address reserved for documentation\n(2001:db8::/32).",91,null],[11,"is_unicast_global","","Returns true if the address is a globally routable unicast address.",91,null],[11,"multicast_scope","","Returns the address&#39;s multicast scope if the address is multicast.",91,null],[11,"is_multicast","","Returns true if this is a multicast address (ff00::/8).",91,null],[11,"to_ipv4","","Converts this address to an IPv4 address. Returns None if this address is\nneither IPv4-compatible or IPv4-mapped.",91,null],[11,"octets","","Returns the sixteen eight-bit integers the IPv6 address consists of.",91,null],[11,"max","","Returns the most verbose logging level.",58,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",58,null],[11,"new","","Create a new `Path` instance with a timeout of 10 minutes and 1 million connections at a\nmaximum",59,{"inputs":[],"output":{"name":"path"}}],[11,"set_log_level","","Set the global log level for reporting",59,null],[11,"track","","Track a connection based on its `Identifier`",59,null],[11,"connection_count","","Get the number of actual tracked connections",59,null],[11,"last_mut","","Retrieve the last `Connection` as a mutable reference if available",59,null],[11,"remove","","Remove a connection",59,null],[11,"flush","","Remove all connections which have a timeout and return them in a vector",59,null],[11,"new","","Create a new `Connection` from an `Identifier` and `Data`",60,{"inputs":[{"name":"identifier"},{"name":"data"}],"output":{"name":"connection"}}],[11,"new","","Create new connection data",61,{"inputs":[],"output":{"name":"data"}}],[11,"packet_counter","","Retrieve the current packet counter value",61,null],[11,"new","","Create a new `Identifier` from needed connection information",62,{"inputs":[{"name":"ipaddr"},{"name":"u16"},{"name":"ipaddr"},{"name":"u16"},{"name":"k"}],"output":{"name":"identifier"}}]],"paths":[[3,"EthernetPacket"],[3,"MacAddress"],[4,"EtherType"],[3,"EthernetParser"],[3,"ArpPacket"],[4,"ArpHardwareType"],[4,"ArpOperation"],[3,"ArpParser"],[3,"Ipv4Packet"],[4,"IpProtocol"],[3,"Ipv4Parser"],[3,"Ipv6Packet"],[3,"Ipv6Parser"],[3,"IcmpPacket"],[3,"IcmpEcho"],[4,"IcmpType"],[4,"IcmpData"],[3,"IcmpParser"],[3,"Icmpv6Packet"],[4,"Icmpv6Type"],[4,"Icmpv6Data"],[3,"Icmpv6Parser"],[3,"TcpPacket"],[3,"TcpHeader"],[3,"TcpParser"],[3,"TlsPacket"],[3,"TlsRecordVersion"],[4,"TlsRecordContentType"],[3,"TlsParser"],[3,"UdpPacket"],[3,"UdpHeader"],[3,"UdpParser"],[3,"HttpRequest"],[3,"HttpVersion"],[3,"HttpHeader"],[3,"HttpResponse"],[4,"HttpPacket"],[4,"HttpRequestMethod"],[3,"HttpParser"],[3,"NtpPacket"],[3,"NtpParser"],[8,"Debug"],[8,"Binary"],[8,"UpperHex"],[8,"Pointer"],[8,"Octal"],[8,"UpperExp"],[8,"LowerHex"],[8,"Write"],[8,"LowerExp"],[8,"Display"],[8,"Error"],[8,"Pattern"],[4,"SearchStep"],[8,"Searcher"],[8,"ReverseSearcher"],[8,"FromStr"],[4,"IpAddr"],[4,"LogLevel"],[3,"Path"],[3,"Connection"],[3,"Data"],[3,"Identifier"],[4,"PathErrorType"],[8,"NewPeelIp"],[3,"Bytes"],[3,"CharSearcher"],[3,"CharSliceSearcher"],[3,"CharPredicateSearcher"],[3,"StrSearcher"],[3,"Arguments"],[3,"ParseBoolError"],[3,"Utf8Error"],[3,"Chars"],[3,"CharIndices"],[3,"Split"],[3,"RSplit"],[3,"SplitTerminator"],[3,"RSplitTerminator"],[3,"SplitN"],[3,"RSplitN"],[3,"MatchIndices"],[3,"RMatchIndices"],[3,"Matches"],[3,"RMatches"],[3,"Lines"],[3,"LinesAny"],[3,"Error"],[3,"Formatter"],[3,"SplitWhitespace"],[3,"Ipv4Addr"],[3,"Ipv6Addr"],[3,"EncodeUtf16"],[3,"DebugStruct"],[3,"DebugList"],[3,"DebugSet"],[3,"DebugTuple"],[3,"DebugMap"]]};
initSearch(searchIndex);
